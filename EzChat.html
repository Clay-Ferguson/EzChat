<!DOCTYPE html>
<html lang="en">
<!-- EzChat: A simple WebRTC chat application. This app allows multiple users to connect and chat in real-time using WebRTC technology. 
     It includes features for setting user names, sending messages, and 
     displaying participant status. The signaling server is assumed to be 
     running on ws://localhost:8080, and we are expecting the Signaling Server in use to be our own which is in this project as `EzChatServer.js`.
     The server should handle WebSocket connections and manage the signaling process for WebRTC peer connections.
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EzChat</title>
    <script src="/public/marked.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #000000;
            color: #e7e9ea;
        }

        #chatLog {
            height: 300px;
            border: 1px solid #333;
            margin-bottom: 10px;
            margin-top: 10px;
            padding: 10px;
            overflow-y: auto;
            background-color: #16181c;
        }

        .form-control {
            margin-bottom: 10px;
            margin-right: 10px;
            background-color: #16181c;
            color: #e7e9ea;
            border: 1px solid #333;
            padding: 8px;
        }

        #messageInput {
            width: 70%;
            padding: 8px;
            min-height: 60px;
            resize: vertical;
            font-family: Arial, sans-serif;
            background-color: #16181c;
            color: #e7e9ea;
            border: 1px solid #333;
        }

        #sendButton,
        #connectButton {
            padding: 8px 15px;
            background-color: #1d9bf0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #sendButton:hover,
        #connectButton:hover {
            background-color: #1a8cd8;
        }

        #sendButton:disabled,
        #connectButton:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }

        .status {
            color: #71767b;
            font-style: italic;
        }

        .message {
            margin: 5px 0;
        }

        .local {
            color: #1d9bf0;
            text-align: right;
        }

        .remote {
            color: #8ecdf8;
        }

        .system {
            color: #71767b;
            font-style: italic;
            text-align: center;
        }

        #participantsList {
            margin: 10px 0;
            font-size: 0.9em;
            color: #71767b;
        }

        /* Add styles for markdown content */
        .message-content {
            display: inline-block;
            text-align: left;
        }

        .message-content code {
            background-color: #2a2d34;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
            color: #e7e9ea;
        }

        .message-content pre {
            background-color: #2a2d34;
            padding: 8px;
            border-radius: 3px;
            overflow-x: auto;
            color: #e7e9ea;
        }

        .message-content img {
            max-width: 100%;
            height: auto;
        }

        .message-content blockquote {
            border-left: 3px solid #333;
            margin-left: 0;
            padding-left: 10px;
            color: #8b98a5;
        }

        .message-content table {
            border-collapse: collapse;
        }

        .message-content th,
        .message-content td {
            border: 1px solid #333;
            padding: 5px;
        }

        label {
            color: #e7e9ea;
        }

        h6 {
            color: #e7e9ea;
        }
    </style>
</head>

<body>

    <h6 id="participantsList">EzChat: Ready to connect</h6>
    <div class="form-group">
        <label for="username">Username:</label>
        <input type="text" id="username" placeholder="Your name" class="form-control">

        <label for="roomId">Room:</label>
        <input type="text" id="roomId" placeholder="Room name" value="default-room" class="form-control">

        <button id="connectButton">Connect</button>
    </div>

    <div id="chatLog"></div>
    <div id="connectionStatus" class="status">Disconnected</div>
    <div>
        <textarea id="messageInput" placeholder="Type your message..." disabled></textarea>
        <button id="sendButton" disabled>Send</button>
    </div>

    <script>
        // Debug logging function
        function log(message) {
            console.log('[WebRTC Chat] ' + message);
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = message;
        }

        // Message storage and persistence functions
        function saveRoomMessages(roomId, messages) {
            try {
                // Get existing room data or create a new room object
                const roomData = {
                    messages,
                    lastUpdated: new Date().toISOString()
                };

                // Save to localStorage with room ID as key
                localStorage.setItem('ezchat_room_' + roomId, JSON.stringify(roomData));
                log('Saved ' + messages.length + ' messages for room: ' + roomId);
            } catch (error) {
                log('Error saving messages to localStorage: ' + error);
            }
        }

        function loadRoomMessages(roomId) {
            try {
                const roomDataStr = localStorage.getItem('ezchat_room_' + roomId);
                if (roomDataStr) {
                    const roomData = JSON.parse(roomDataStr);
                    log('Loaded ' + roomData.messages.length + ' messages for room: ' + roomId);
                    return roomData.messages || [];
                }
            } catch (error) {
                log('Error loading messages from localStorage: ' + error);
            }
            return [];
        }

        // Load and display all messages for a room
        function displayRoomHistory(roomId) {
            const messages = loadRoomMessages(roomId);

            // Clear the current chat log
            const chatLog = document.getElementById('chatLog');
            chatLog.innerHTML = '';

            // Display system message about history
            if (messages.length > 0) {
                const systemMsg = document.createElement('div');
                systemMsg.classList.add('message', 'system');
                systemMsg.textContent = 'Loading message history...';
                chatLog.appendChild(systemMsg);


                messages.forEach(msg => {
                    // print the message to the console
                    console.log('Message from ' + msg.sender + ': ' + msg.content + ' at ' + msg.timestamp);

                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('message');

                    if (msg.sender === userName) {
                        messageDiv.classList.add('local');

                        const senderSpan = document.createElement('span');
                        senderSpan.textContent = 'You: ';
                        messageDiv.appendChild(senderSpan);
                    } else {
                        messageDiv.classList.add('remote');

                        const senderSpan = document.createElement('span');
                        senderSpan.textContent = msg.sender + ': ';
                        messageDiv.appendChild(senderSpan);
                    }

                    const messageContent = document.createElement('div');
                    messageContent.classList.add('message-content');
                    messageContent.innerHTML = marked.parse(msg.content);
                    messageDiv.appendChild(messageContent);

                    chatLog.appendChild(messageDiv);
                });

                const endMsg = document.createElement('div');
                endMsg.classList.add('message', 'system');
                endMsg.textContent = 'End of message history';
                chatLog.appendChild(endMsg);
            } else {
                const noHistoryMsg = document.createElement('div');
                noHistoryMsg.classList.add('message', 'system');
                noHistoryMsg.textContent = 'No message history for this room';
                chatLog.appendChild(noHistoryMsg);
            }

            // Scroll to bottom
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // Modified displayMessage function to render markdown and store messages
        // function displayMessage(message, sender, saveMessage = true) {
        function displayMessage(messageData) {
            console.log("Displaying message from " + messageData.sender + ": " + messageData.content);
            const chatLog = document.getElementById('chatLog');
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');

            if (messageData.sender === 'system') {
                messageDiv.classList.add('system');
                messageDiv.textContent = messageData.content;
            } else {
                // Create container for rendered markdown
                const messageContent = document.createElement('div');
                messageContent.classList.add('message-content');

                if (messageData.sender === userName) {
                    messageDiv.classList.add('local');

                    // Add sender prefix
                    const senderSpan = document.createElement('span');
                    senderSpan.textContent = 'You: ';
                    messageDiv.appendChild(senderSpan);
                } else {
                    messageDiv.classList.add('remote');

                    // Add sender prefix
                    const senderSpan = document.createElement('span');
                    senderSpan.textContent = messageData.sender + ': ';
                    messageDiv.appendChild(senderSpan);
                }

                // Render markdown content
                messageContent.innerHTML = marked.parse(messageData.content);
                messageDiv.appendChild(messageContent);
            }

            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // WebRTC connection
        let peerConnections = new Map(); // peer name -> connection
        let dataChannels = new Map();    // peer name -> channel
        let signalingSocket = null;
        let roomId = localStorage.getItem('ezchat_room') || 'default-room'; // Load from localStorage or use default
        let userName = localStorage.getItem('ezchat_username') || 'user-' + Math.floor(Math.random() * 10000); // Load from localStorage or generate
        let participants = new Set();
        let isSignalConnected = false;

        function updateParticipantsList() {
            const list = document.getElementById('participantsList');
            if (participants.size === 0) {
                list.textContent = 'EzChat: No participants yet';
            } else {
                list.textContent = 'EzChat with: ' + Array.from(participants).join(', ');
            }
        }

        function updateConnectionStatus() {
            // Enable input if we have at least one open data channel or we're connected to the signaling server
            const hasOpenChannel = Array.from(dataChannels.values()).some(channel => channel.readyState === 'open');
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');

            if (hasOpenChannel || isSignalConnected) {
                messageInput.disabled = false;
                sendButton.disabled = false;
                document.getElementById('connectionStatus').textContent = hasOpenChannel ?
                    'Connected via WebRTC' : 'Connected via server';
            } else {
                messageInput.disabled = true;
                sendButton.disabled = true;
                document.getElementById('connectionStatus').textContent = 'Disconnected';
            }
        }

        function createPeerConnection(peerName, isInitiator) {
            log('Creating peer connection with ' + peerName + (isInitiator ? ' (as initiator)' : ''));

            // Create a new peer connection for this peer
            const pc = new RTCPeerConnection();

            peerConnections.set(peerName, pc);

            // Set up ICE candidate handling
            pc.onicecandidate = event => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        target: peerName,
                        room: roomId
                    }));
                    log('Sent ICE candidate to ' + peerName);
                }
            };

            // Connection state changes
            pc.onconnectionstatechange = () => {
                log('Connection state with ' + peerName + ': ' + pc.connectionState);
                if (pc.connectionState === 'connected') {
                    log('WebRTC connected with ' + peerName + '!');
                    updateConnectionStatus();
                } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    log('WebRTC disconnected from ' + peerName);
                    updateConnectionStatus();
                }
            };

            // Handle incoming data channels
            pc.ondatachannel = event => {
                log('Received data channel from ' + peerName);
                setupDataChannel(event.channel, peerName);
            };

            // If we're the initiator, create a data channel
            if (isInitiator) {
                try {
                    log('Creating data channel as initiator for ' + peerName);
                    const channel = pc.createDataChannel('chat');
                    setupDataChannel(channel, peerName);

                    // Create and send offer
                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .then(() => {
                            signalingSocket.send(JSON.stringify({
                                type: 'offer',
                                offer: pc.localDescription,
                                target: peerName,
                                room: roomId
                            }));
                            log('Sent offer to ' + peerName);
                        })
                        .catch(error => log('Error creating offer: ' + error));
                } catch (err) {
                    log('Error creating data channel: ' + err);
                }
            }

            return pc;
        }

        function setupDataChannel(channel, peerName) {
            log('Setting up data channel for ' + peerName);

            dataChannels.set(peerName, channel);

            channel.onopen = function () {
                log('Data channel open with ' + peerName);
                updateConnectionStatus();
            };

            channel.onclose = function () {
                log('Data channel closed with ' + peerName);
                dataChannels.delete(peerName);
                updateConnectionStatus();
            };

            channel.onmessage = function (event) {
                log('onMessage. Received message from ' + peerName + ': ' + event.data);
                persistMessage(event.data);
                displayMessage(event.data);
            };

            channel.onerror = function (error) {
                log('Data channel error with ' + peerName + ': ' + error);
                updateConnectionStatus();
            };
        }

        function initWebRTC() {
            log('Starting WebRTC connection setup...');

            // Create WebSocket connection to signaling server
            signalingSocket = new WebSocket('ws://localhost:8080');

            signalingSocket.onopen = function () {
                log('Connected to signaling server.');
                isSignalConnected = true;
                updateConnectionStatus();

                // Join a room with user name
                signalingSocket.send(JSON.stringify({
                    type: 'join',
                    room: roomId,
                    name: userName
                }));
                log('Joining room: ' + roomId + ' as ' + userName);
            };

            signalingSocket.onmessage = function (event) {
                const message = JSON.parse(event.data);

                // Handle room information (received when joining)
                if (message.type === 'room-info') {
                    log('Room info received with participants: ' + message.participants.join(', '));

                    // Update our list of participants
                    participants = new Set(message.participants);
                    updateParticipantsList();

                    // For each participant, create a peer connection and make an offer
                    message.participants.forEach(participant => {
                        if (!peerConnections.has(participant)) {
                            createPeerConnection(participant, true);
                        }
                    });
                }

                // Handle user joined event
                else if (message.type === 'user-joined') {
                    log('User joined: ' + message.name);
                    participants.add(message.name);
                    updateParticipantsList();

                    messageData = createMessage(message.name + ' joined the chat', 'system');
                    displayMessage(messageData);

                    // Create a connection with the new user (we are initiator)
                    if (!peerConnections.has(message.name)) {
                        createPeerConnection(message.name, true);
                    }
                }

                // Handle user left event
                else if (message.type === 'user-left') {
                    log('User left: ' + message.name);
                    participants.delete(message.name);
                    updateParticipantsList();

                    messageData = createMessage(message.name + ' left the chat', 'system');
                    displayMessage(messageData);

                    // Clean up connections
                    if (peerConnections.has(message.name)) {
                        peerConnections.get(message.name).close();
                        peerConnections.delete(message.name);
                    }

                    if (dataChannels.has(message.name)) {
                        dataChannels.delete(message.name);
                    }

                    updateConnectionStatus();
                }

                // Handle WebRTC signaling messages
                else if (message.type === 'offer' && message.sender) {
                    log('Received offer from ' + message.sender);

                    // Create a connection if it doesn't exist
                    let pc;
                    if (!peerConnections.has(message.sender)) {
                        pc = createPeerConnection(message.sender, false);
                    } else {
                        pc = peerConnections.get(message.sender);
                    }

                    pc.setRemoteDescription(new RTCSessionDescription(message.offer))
                        .then(() => pc.createAnswer())
                        .then(answer => pc.setLocalDescription(answer))
                        .then(() => {
                            signalingSocket.send(JSON.stringify({
                                type: 'answer',
                                answer: pc.localDescription,
                                target: message.sender,
                                room: roomId
                            }));
                            log('Sent answer to ' + message.sender);
                        })
                        .catch(error => log('Error creating answer: ' + error));
                }

                else if (message.type === 'answer' && message.sender) {
                    log('Received answer from ' + message.sender);
                    if (peerConnections.has(message.sender)) {
                        peerConnections.get(message.sender)
                            .setRemoteDescription(new RTCSessionDescription(message.answer))
                            .catch(error => log('Error setting remote description: ' + error));
                    }
                }

                else if (message.type === 'ice-candidate' && message.sender) {
                    log('Received ICE candidate from ' + message.sender);
                    if (peerConnections.has(message.sender)) {
                        peerConnections.get(message.sender)
                            .addIceCandidate(new RTCIceCandidate(message.candidate))
                            .catch(error => log('Error adding ICE candidate: ' + error));
                    }
                }

                // Handle broadcast messages
                else if (message.type === 'broadcast' && message.sender) {
                    log('broadcast. Received broadcast message from ' + message.sender);
                    persistMessage(message.messageData);
                    displayMessage(message.messageData);
                }
            };

            signalingSocket.onerror = function (error) {
                log('WebSocket error: ' + error);
                isSignalConnected = false;
                updateConnectionStatus();
            };

            signalingSocket.onclose = function () {
                log('Disconnected from signaling server');
                isSignalConnected = false;

                // Clean up all connections
                peerConnections.forEach(pc => pc.close());
                peerConnections.clear();
                dataChannels.clear();

                updateConnectionStatus();
            };
        }

        // Send message function
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (message) {
                log('Sending message: ' + message);
                messageData = createMessage(message, userName);
                persistMessage(messageData);
                displayMessage(messageData);

                // Try to send through data channels first
                let channelsSent = 0;
                dataChannels.forEach((channel, peer) => {
                    if (channel.readyState === 'open') {
                        channel.send(messageData);
                        channelsSent++;
                    }
                });

                // If no channels are ready or no peers, send through signaling server
                if ((channelsSent === 0 || participants.size === 0) &&
                    signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                    signalingSocket.send(JSON.stringify({
                        type: 'broadcast',
                        messageData,
                        room: roomId
                    }));
                    log('Sent message via signaling server');
                }

                input.value = '';
            }
        }

        function createMessage(content, sender) {
            const messageData = {
                timestamp: new Date().toISOString(),
                sender,
                content
            };
            return messageData;
        }

        function persistMessage(messageData) {
            // Get current messages, add new one, and save
            // todo-0: need to only READ messages one time.
            const messages = loadRoomMessages(roomId);

            // messages will be objects having timestamp, sender, and content
            // We need to scan all 'messages' and if the message is already there, we return from this method
            for (let i = 0; i < messages.length; i++) {
                if (messages[i].timestamp === messageData.timestamp && //
                    messages[i].sender === messageData.sender && //
                    messages[i].content === messageData.content) {
                    return false; // Message already exists, do not save again
                }
            }

            messages.push(messageData);
            saveRoomMessages(roomId, messages);
            return true;
        }

        function connect() {
            const usernameInput = document.getElementById('username');
            const name = usernameInput.value.trim();

            // Get the room ID from the input field
            const roomInput = document.getElementById('roomId');
            const newRoomId = roomInput.value.trim() || 'default-room';

            if (name) {
                const oldName = userName;
                userName = name;
                roomId = newRoomId; // Set the room ID from the input

                // Save username and room to localStorage
                localStorage.setItem('ezchat_username', userName);
                localStorage.setItem('ezchat_room', roomId);

                log('Name changed from ' + oldName + ' to ' + userName);
                log('Joining room: ' + roomId);

                // Display message history for this room
                displayRoomHistory(roomId);

                // If already connected, reset connection with new name and room
                if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                    // Clean up all connections
                    peerConnections.forEach(pc => pc.close());
                    peerConnections.clear();
                    dataChannels.clear();

                    // Rejoin with new name and room
                    signalingSocket.send(JSON.stringify({
                        type: 'join',
                        room: roomId,
                        name: userName
                    }));
                    log('Joining room: ' + roomId + ' as ' + userName);
                } else {
                    // Initialize connection with new name
                    initWebRTC();
                }

                // Optionally disable changing rooms after joining
                roomInput.disabled = true;
                usernameInput.disabled = true;
                document.getElementById('connectButton').disabled = true;
            }
        }

        // Initialize the form with saved values when page loads
        function initForm() {
            // Set the input fields with the values from localStorage
            const usernameInput = document.getElementById('username');
            const roomInput = document.getElementById('roomId');
            
            usernameInput.value = userName;
            roomInput.value = roomId;
        }

        // Event listeners
        document.getElementById('connectButton').addEventListener('click', connect);
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        
        // Initialize the form when page loads
        initForm();

    </script>
</body>

</html>